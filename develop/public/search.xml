<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[指令备忘录]]></title>
      <url>/2020/01/10/%E6%8C%87%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="指令备忘录"><a href="#指令备忘录" class="headerlink" title="指令备忘录"></a>指令备忘录</h1><p>老年人记忆力</p>
<h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><blockquote>
<p>itar</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            int i1 = a[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>iter</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i : a) &#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看该类全部方法"><a href="#查看该类全部方法" class="headerlink" title="查看该类全部方法"></a>查看该类全部方法</h3><blockquote>
<p>Alt + 7</p>
</blockquote>
<h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><blockquote>
<p>soutp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;a = &quot; + Arrays.toString(a));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>soutv</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;a = &quot; + a);</span><br></pre></td></tr></table></figure>

<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="设置仓库的邮箱以及用户名"><a href="#设置仓库的邮箱以及用户名" class="headerlink" title="设置仓库的邮箱以及用户名"></a>设置仓库的邮箱以及用户名</h3><blockquote>
<p>git config user.name “eatboooo”</p>
</blockquote>
<blockquote>
<p>git config user.email “<a href="mailto:571241210@qq.com" target="_blank" rel="noopener">571241210@qq.com</a>“</p>
</blockquote>
<blockquote>
<p>git config –list</p>
</blockquote>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><blockquote>
<p>git checkout</p>
</blockquote>
<h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><h3 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h3><blockquote>
<p>hexo g -d</p>
</blockquote>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Lambda-表达式打印"><a href="#Lambda-表达式打印" class="headerlink" title="Lambda 表达式打印"></a>Lambda 表达式打印</h3><p>JDK 8 新特性</p>
<blockquote>
<p>List<string> players =  Arrays.asList(atp);<br>players.forEach(System.out::println);  </string></p>
</blockquote>
<h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><h3 id="打包指令（针对-win10）"><a href="#打包指令（针对-win10）" class="headerlink" title="打包指令（针对 win10）"></a>打包指令（针对 win10）</h3><blockquote>
<p>go build -ldflags “-extldflags &quot;-static&quot; -s -w”</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 备忘录 </category>
            
            <category> 指令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 指令 </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang祖安助手]]></title>
      <url>/2019/11/18/golang%E7%A5%96%E5%AE%89%E5%8A%A9%E6%89%8B/</url>
      <content type="html"><![CDATA[<h1 id="祖安助手"><a href="#祖安助手" class="headerlink" title="祖安助手"></a>祖安助手</h1><p>分为两个版本</p>
<ul>
<li>文件读取版本</li>
<li>网络请求版本<h2 id="文件读取版本"><a href="#文件读取版本" class="headerlink" title="文件读取版本"></a>文件读取版本</h2>读取本地的 test.txt 文件，把文件内容用分号隔开，以数组的形式存入到内存中，同时监听键盘按键，每次触发按键后在数组中依次读取语句存入到剪切板中。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"gitee.com/veni0/robotgo"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法用于读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFile</span><span class="params">(name <span class="keyword">string</span>)</span> [] <span class="title">string</span></span> &#123;</span><br><span class="line">	data, err := ioutil.ReadFile(name) <span class="comment">//读取文件</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"File reading error"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Contents of file:"</span>, <span class="keyword">string</span>(data)) <span class="comment">//打印文件内容</span></span><br><span class="line">	split := strings.Split(<span class="keyword">string</span>(data), <span class="string">";"</span>)      <span class="comment">//用分号隔开文件内容，并以数组的形式返回</span></span><br><span class="line">	<span class="keyword">return</span> split</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法用于把string字符串存入到剪切板中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putMsg</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	clipboard.WriteAll(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"---祖安助手！---"</span>)</span><br><span class="line">	msg := getFile(<span class="string">"test.txt"</span>)   <span class="comment">//读取文件</span></span><br><span class="line">	eve := robotgo.AddEvent(<span class="string">"v"</span>) <span class="comment">//开始监听</span></span><br><span class="line">	<span class="comment">//robotgo.KeyTap("a", "ctrl")</span></span><br><span class="line">	<span class="comment">//全局监听事件</span></span><br><span class="line">	fmt.Println(<span class="string">"---请按v键---"</span>)</span><br><span class="line">	<span class="comment">// 循环遍历数组</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; eve; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(msg) &#123;</span><br><span class="line">			putMsg(msg[i])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			i = <span class="number">0</span></span><br><span class="line">			putMsg(msg[<span class="number">0</span>] + <span class="string">"\n"</span>) <span class="comment">//当 i 超过数组长度时，修改 i 的值并且把 msg【0】 存入到剪切板中。</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"---你按下v键---"</span>, <span class="string">"v"</span>)</span><br><span class="line">		eve = robotgo.AddEvent(<span class="string">"v"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="网络请求版本"><a href="#网络请求版本" class="headerlink" title="网络请求版本"></a>网络请求版本</h2><p>向网站 <a href="https://nmsl.shadiao.app/" target="_blank" rel="noopener">骂人宝典</a> 发送 get 请求，把 response 转换成string存入到剪切板中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"gitee.com/veni0/robotgo"</span></span><br><span class="line">	<span class="string">"github.com/atotto/clipboard"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法用于模拟发送get请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	resp, err := client.Get(<span class="string">"https://nmsl.shadiao.app/api.php?lang=zh_cn"</span>) <span class="comment">//发送get请求,并接收response</span></span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	body, err := ioutil.ReadAll(resp.Body) <span class="comment">//读取response</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(body) <span class="comment">//以string的形式返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法用于把string字符串存入到剪切板中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putMsg</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	clipboard.WriteAll(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"---祖安助手！---"</span>)</span><br><span class="line">	putMsg(GetData()) </span><br><span class="line">	eve := robotgo.AddEvent(<span class="string">"v"</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> eve &#123;</span><br><span class="line">		putMsg(GetData())</span><br><span class="line">		fmt.Println(<span class="string">"---你按下v键，剪切板生成了以下内容---"</span>, <span class="string">"v"</span>)</span><br><span class="line">		eve = robotgo.AddEvent(<span class="string">"v"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 小知识 </category>
            
            <category> golang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> golang </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络知识]]></title>
      <url>/2019/11/04/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="★★★-各层协议的作用，以及-TCP-IP-协议的特点。"><a href="#★★★-各层协议的作用，以及-TCP-IP-协议的特点。" class="headerlink" title="★★★ 各层协议的作用，以及 TCP/IP 协议的特点。"></a>★★★ 各层协议的作用，以及 TCP/IP 协议的特点。</h3><figure class="image-box">
                <img src="http://111.231.250.175/img/thumb/network_structure.jpg" alt="network_structure" title class>
                <p>network_structure</p>
            </figure>  
<h4 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h4><ul>
<li>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li>传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li>网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
<li>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。<h4 id="OSI-Open-System-Interconnection-开放系统互连"><a href="#OSI-Open-System-Interconnection-开放系统互连" class="headerlink" title="OSI(Open System Interconnection 开放系统互连)"></a>OSI(Open System Interconnection 开放系统互连)</h4>其中表示层和会话层用途如下：</li>
<li>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li>会话层 ：建立及管理会话。</li>
</ul>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
<h4 id="TCP-IP-Transfer-Control-Protocol-Internet-Protocol"><a href="#TCP-IP-Transfer-Control-Protocol-Internet-Protocol" class="headerlink" title="TCP/IP(Transfer Control Protocol / Internet Protocol)"></a>TCP/IP(Transfer Control Protocol / Internet Protocol)</h4><figure class="image-box">
                <img src="http://111.231.250.175/img/thumb/TCP_IP_structure.png" alt="network_structure" title class>
                <p>network_structure</p>
            </figure>  
<p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<h4 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h4><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<h3 id="★★★-UDP-与-TCP-比较，分析上层协议应该使用-UDP-还是-TCP。"><a href="#★★★-UDP-与-TCP-比较，分析上层协议应该使用-UDP-还是-TCP。" class="headerlink" title="★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。"></a>★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。</h3><figure class="image-box">
                <img src="http://111.231.250.175/img/thumb/TCP_UDP.jpg" alt="network_structure" title class>
                <p>network_structure</p>
            </figure>  
<ul>
<li><p>UDP:  </p>
<ul>
<li><p>User Datagram ProtocolInternet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。</p>
</li>
<li><p>使用 UDP 协议不需要建立连接，只需要知道对方的 IP地址和端口号，就可以直接发数据包。但不能保证数据是否能准确到达。虽然用 UDP 传输数据不可靠，但它的优点是速度快，支持多对多的通信。对于不要求可靠到达的或对时效性要求较高数据，就可以使用 UDP 协议。<br>比如实时互动直播就只能用 UDP 而不能用 TCP，因为实时互动直播要求传输速度快、时效性要求高(因为我只关心当前直播内容，对于因为网络不好导致延迟或者丢包的数据并不太关心)。如果使用 TCP，当网络不好时，发送的数据丢包或者超时会重发，这样观看者看到的可能就不是当前直播的画面。如果用 UDP 的话，只要有数据就发送，不管能不能到达，即使网络不好，使用 UDP 发送的一直都是最新的直播内容，所以观看者看到的一直都是当前的直播画面。</p>
</li>
<li><p>应用：</p>
<ul>
<li>域名转换;</li>
<li>流媒体；</li>
<li>实时游戏；</li>
<li>物联网；</li>
<li>QQ 文件传输、QQ语音、QQ视频；</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP:</p>
<ul>
<li>Transfer Control Protocol 传输控制协议,是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li>
<li>TCP 协议是建立在 IP 协议之上的，其负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达，如果包丢掉了，就自动重发。<br>创建 TCP 连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。客户端要主动发起 TCP 连接，必须知道服务器的 IP 地址和端口号(互联网上每台计算机的唯一标识就是 IP 地址，只知道 IP 地址是不够的，IP 地址只能保证数据传输到哪台计算机，但是要传到计算机的哪个程序呢？这就必须用到端口号，每个程序都有其对应的端口号，比如 Web 服务的标准端口是 80 )。<br>TCP 的特点是面向连接的，保证数据准确到达，但 TCP 连接只能一对一，而且传输效率相对较低。</li>
<li>应用：<ul>
<li>FTP：文件传输协议；</li>
<li>SSH：安全登录、文件传送(SCP)和端口重定向；</li>
<li>Telnet：不安全的文本传送；</li>
<li>SMTP：简单邮件传输协议Simple Mail Transfer Protocol (E-mail)；</li>
<li>HTTP：超文本传送协议 (WWW)；</li>
</ul>
</li>
</ul>
</li>
<li><p>综上分析上层协议中 域名转换使用 UDP 协议，与服务器连接确保信息准确使用 TCP 协议。</p>
</li>
</ul>
<p>总结如图</p>
<figure class="image-box">
                <img src="https://gitee.com/eatboooo/BlogMd/raw/master/img/TCP_IP_structure2.png" alt="TCP_IP_structure2" title class>
                <p>TCP_IP_structure2</p>
            </figure>

<h3 id="★★★-理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME-WAIT-的作用。"><a href="#★★★-理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME-WAIT-的作用。" class="headerlink" title="★★★ 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。"></a>★★★ 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。</h3><h3 id="★★★-可靠传输原理，并设计可靠-UDP-协议。"><a href="#★★★-可靠传输原理，并设计可靠-UDP-协议。" class="headerlink" title="★★★ 可靠传输原理，并设计可靠 UDP 协议。"></a>★★★ 可靠传输原理，并设计可靠 UDP 协议。</h3><h4 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h4><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li>拥塞控制： 当网络拥塞时，减少数据的发送。</li>
<li>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="★★★-GET-与-POST-比较：作用、参数、安全性、幂等性、可缓存。"><a href="#★★★-GET-与-POST-比较：作用、参数、安全性、幂等性、可缓存。" class="headerlink" title="★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。"></a>★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。</h3><p>这里特指浏览器中非 Ajax 的 HTTP 请求，即从 HTML 和浏览器诞生就一直使用的 HTTP 协议中的 GET/POST 。浏览器用 GET 请求来获取一个 html 页面/图片/css/js等资源；用 POST 来提交一个 form 表单，并得到一个结果的网页。</p>
<p>读取“一个资源。比如 Get 到一个 html 文件。反复读取不应该对访问的数据有副作用。没有副作用被称为“幂等“（Idempotent)。</p>
<ul>
<li>GET - 从指定的资源请求数据。<ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据</li>
</ul>
</li>
<li>POST - 向指定的资源提交要被处理的数据<ul>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>后退按钮/刷新</td>
<td>无害</td>
<td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>
</tr>
<tr>
<td>书签</td>
<td>可收藏为书签</td>
<td>不可收藏为书签</td>
</tr>
<tr>
<td>缓存</td>
<td>能被缓存</td>
<td>不能被缓存</td>
</tr>
<tr>
<td>编码类型</td>
<td>application/x-www-form-urlencoded</td>
<td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td>
</tr>
<tr>
<td>历史</td>
<td>参数保留在浏览器历史中。</td>
<td>参数不会保留在浏览器历史中。</td>
</tr>
<tr>
<td>对数据长度的限制</td>
<td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td>
<td>无限制。</td>
</tr>
<tr>
<td>对数据类型的限制</td>
<td>只允许 ASCII 字符。</td>
<td>没有限制。也允许二进制数据。</td>
</tr>
<tr>
<td>安全性</td>
<td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td>
<td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>
</tr>
<tr>
<td>可见性</td>
<td>数据在 URL 中对所有人都是可见的。</td>
<td>数据不会显示在 URL 中。</td>
</tr>
</tbody></table>
<h4 id="GET-与-POST-装逼技巧"><a href="#GET-与-POST-装逼技巧" class="headerlink" title="GET 与 POST 装逼技巧"></a>GET 与 POST 装逼技巧</h4><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p>
<p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的</p>
<p><strong>GET产生一个TCP数据包；POST产生两个TCP数据包。</strong></p>
<ul>
<li><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
</li>
<li><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
</li>
</ul>
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p>
<ol>
<li><p>GET与POST都有自己的语义，不能随便混用。</p>
</li>
<li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p>
</li>
<li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p>
</li>
</ol>
<p>我参考的GET与POST装逼指北： <a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">99%的人都理解错了HTTP中GET与POST的区别</a></p>
<h3 id="★★★-Cookie-作用、安全性问题、和-Session-的比较。"><a href="#★★★-Cookie-作用、安全性问题、和-Session-的比较。" class="headerlink" title="★★★ Cookie 作用、安全性问题、和 Session 的比较。"></a>★★★ Cookie 作用、安全性问题、和 Session 的比较。</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h6 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h6><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）<h5 id="安全属性"><a href="#安全属性" class="headerlink" title="安全属性"></a>安全属性</h5>HTTP 协议不仅是无状态的，而且是不安全的。</li>
</ul>
<p>使用 HTTP 协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。如果不希望 Cookie 在 HTTP 等非安全协议中传输，可以设置 Cookie 的 secure 属性为 true。浏览器只会在 HTTPS 和 SSL 等安全协议中传输此类 Cookie。</p>
<p>Java 中使用setSecure(booleanflag)和getSecure ()方法来设置、获取 Secure。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h3 id="★★★-长连接与短连接原理以及使用场景，流水线。"><a href="#★★★-长连接与短连接原理以及使用场景，流水线。" class="headerlink" title="★★★ 长连接与短连接原理以及使用场景，流水线。"></a>★★★ 长连接与短连接原理以及使用场景，流水线。</h3><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; ………..-&gt;直到一方关闭连接，多是客户端关闭连接。</p>
<p>长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。</p>
<h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>连接-&gt;传输数据-&gt;关闭连接</p>
<p>比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。</p>
<h4 id="流水线（pipeline）"><a href="#流水线（pipeline）" class="headerlink" title="流水线（pipeline）"></a>流水线（pipeline）</h4><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</li>
<li>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</li>
<li>redis中使用pipeline通信，每一次操作redis的时候我们都需要和服务端建立连接,针对量小的情况下网络延迟都是可以忽略的,但是针对大批量的业务,就会产生雪崩效应。假如一次操作耗时2ms,理论上100万次操作就会有2ms * 100万ms延迟,中间加上服务器处理开销,耗时可能更多.对应客户端来讲,这种长时间的耗时是不能接受的。所以为了解决这个问题，redis的管道pipeline就派上用场了</li>
</ul>
<h3 id="★★★-HTTP-存在的安全性问题，以及-HTTPs-的加密、认证和完整性保护作用。"><a href="#★★★-HTTP-存在的安全性问题，以及-HTTPs-的加密、认证和完整性保护作用。" class="headerlink" title="★★★ HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。"></a>★★★ HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。</h3><h4 id="HTTP-存在的安全性问题"><a href="#HTTP-存在的安全性问题" class="headerlink" title="HTTP 存在的安全性问题"></a>HTTP 存在的安全性问题</h4><ul>
<li>使用明文进行通信，内容可能被窃听</li>
<li>不验证通信方的身份，通信方的身份可能遭到伪装</li>
<li>无法证明报文的保证性，报文可能遭到篡改<h4 id="HTTPs-协议"><a href="#HTTPs-协议" class="headerlink" title="HTTPs 协议"></a>HTTPs 协议</h4>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</li>
</ul>
<p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 </p>
<figure class="image-box">
                <img src="https://gitee.com/eatboooo/BlogMd/raw/master/img/HTTPs_principle.jpg" alt="HTTPs_principle" title class>
                <p>HTTPs_principle</p>
            </figure>
<h5 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h5><p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。</p>
<h5 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h5><p>安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。</p>
<p>该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。</p>
<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><ol>
<li>对称密钥加密<br>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</li>
</ol>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<ol>
<li>非对称密钥加密<br>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。<br>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。<br>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</li>
</ol>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度相对对称加密慢。</li>
</ul>
<ol>
<li>HTTPs 采用的加密方式<br>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）<figure class="image-box">
                <img src="https://gitee.com/eatboooo/BlogMd/raw/master/img/HTTPs_encryption.png" alt="HTTPs_encryption" title class>
                <p>HTTPs_encryption</p>
            </figure>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4>通过使用 证书 来对通信方进行认证。</li>
</ol>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了</p>
<figure class="image-box">
                <img src="https://gitee.com/eatboooo/BlogMd/raw/master/img/CertificateAuthority.png" alt="CertificateAuthority" title class>
                <p>CertificateAuthority</p>
            </figure>
<h4 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h4><p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h4 id="HTTPs-的缺点"><a href="#HTTPs-的缺点" class="headerlink" title="HTTPs 的缺点"></a>HTTPs 的缺点</h4><ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。<h3 id="★★★-HTTP-1-1-的特性。"><a href="#★★★-HTTP-1-1-的特性。" class="headerlink" title="★★★ HTTP/1.1 的特性。"></a>★★★ HTTP/1.1 的特性。</h3></li>
<li>默认是长连接</li>
<li>支持流水线</li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100<br>  客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h3 id="★★★-select、poll、epoll-的原理、比较、以及使用场景；epoll-的水平触发与边缘触发。"><a href="#★★★-select、poll、epoll-的原理、比较、以及使用场景；epoll-的水平触发与边缘触发。" class="headerlink" title="★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发。"></a>★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发。</h3></li>
</ul>
<hr>
<p>此博客参考资料：   </p>
<ul>
<li><a href="https://github.com/CyC2018/Backend-Interview-Guide" target="_blank" rel="noopener">后端面试进阶指南</a></li>
<li><a href="https://github.com/Jeloys/HelloWorld/blob/f16fdb4295d8520a968fbf4672367f5d0a4e0fba/%E7%BD%91%E7%BB%9C/HTTP%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86.md" target="_blank" rel="noopener">HTTP问题合集</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md" target="_blank" rel="noopener">计算机网络</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">99%的人都理解错了HTTP中GET与POST的区别</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 小知识 </category>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 重要 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java线程]]></title>
      <url>/2019/11/04/Java%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><p>Java 并发中线程的基础知识整理。<br>Java 多线程中的三大特性：原子性，可见性，顺序性。</p>
<h2 id="1-Java-线程生命周期中有哪些状态？各状态之间如何切换？"><a href="#1-Java-线程生命周期中有哪些状态？各状态之间如何切换？" class="headerlink" title="1 Java 线程生命周期中有哪些状态？各状态之间如何切换？"></a>1 Java 线程生命周期中有哪些状态？各状态之间如何切换？</h2><figure class="image-box">
                <img src="http://111.231.250.175/img/thumb/java_thread_status.png" alt="java_thread_status" title class>
                <p>java_thread_status</p>
            </figure>  
<p>java.lang.Thread.State 中定义了 6 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。  </p>
<ul>
<li>开始（New） - 还没有调用 start() 方法的线程处于此状态。</li>
<li>可运行（Runnable） - 已经调用了 start() 方法的线程状态。此状态意味着，线程已经准备好了，一旦被线程调度器分配了 CPU 时间片，就可以运行线程。</li>
<li>阻塞（Blocked） - 阻塞状态。线程阻塞的线程状态等待监视器锁定。处于阻塞状态的线程正在等待监视器锁定，以便在调用 Object.wait() 之后输入同步块/方法或重新输入同步块/方法。</li>
<li>等待（Waiting） - 等待状态。一个线程处于等待状态，是由于执行了 3 个方法中的任意方法：<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()</li>
</ul>
</li>
<li>定时等待（Timed waiting） - 等待指定时间的状态。一个线程处于定时等待状态，是由于执行了以下方法中的任意方法：<ul>
<li>Thread.sleep(sleeptime)</li>
<li>Object.wait(timeout)</li>
<li>Thread.join(timeout)</li>
<li>LockSupport.parkNanos(timeout)</li>
<li>LockSupport.parkUntil(timeout)</li>
</ul>
</li>
<li>终止(Terminated) - 线程 run() 方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ul>
<h2 id="2-创建线程有哪些方式？这些方法各自利弊是什么？"><a href="#2-创建线程有哪些方式？这些方法各自利弊是什么？" class="headerlink" title="2 创建线程有哪些方式？这些方法各自利弊是什么？"></a>2 创建线程有哪些方式？这些方法各自利弊是什么？</h2><p>创建线程主要有三种方式：</p>
<ol>
<li>继承 Thread 类<ul>
<li>定义 Thread 类的子类，并重写该类的 run() 方法，该 run() 方法的方法体就代表了线程要完成的任务。因此把 run() 方法称为执行体。</li>
<li>创建 Thread 子类的实例，即创建了线程对象。<br>调用线程对象的 start() 方法来启动该线程。  </li>
</ul>
</li>
<li>实现 Runnable 接口<ul>
<li>定义 Runnable 接口的实现类，并重写该接口的 run() 方法，该 run() 方法的方法体同样是该线程的线程执行体。</li>
<li>创建 Runnable 实现类的实例，并以此实例作为 Thread 对象，该 Thread 对象才是真正的线程对象。</li>
<li>调用线程对象的 start() 方法来启动该线程。</li>
</ul>
</li>
<li>通过 Callable 接口和 Future 接口<ul>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值<br>三种创建线程方式对比</li>
<li>实现 Runnable 接口优于继承 Thread 类，因为根据开放封闭原则——实现接口更便于扩展；</li>
<li>实现 Runnable 接口的线程没有返回值；而使用 Callable / Future 方式可以让线程有返回值。</li>
</ul>
</li>
</ol>
<h2 id="3-什么是-Callable-和-Future？什么是-FutureTask？"><a href="#3-什么是-Callable-和-Future？什么是-FutureTask？" class="headerlink" title="3 什么是 Callable 和 Future？什么是 FutureTask？"></a>3 什么是 Callable 和 Future？什么是 FutureTask？</h2><h3 id="什么是-Callable-和-Future？"><a href="#什么是-Callable-和-Future？" class="headerlink" title="什么是 Callable 和 Future？"></a>什么是 Callable 和 Future？</h3><p>Java 5 在 concurrency 包中引入了 Callable 接口，它和 Runnable 接口很相似，但它可以返回一个对象或者抛出一个异常。</p>
<p>Callable 接口使用泛型去定义它的返回类型。Executors 类提供了一些有用的方法去在线程池中执行 Callable 内的任务。由于 Callable 任务是并行的，我们必须等待它返回的结果。Future 对象为我们解决了这个问题。在线程池提交 Callable 任务后返回了一个 Future 对象，使用它我们可以知道 Callable 任务的状态和得到 Callable 返回的执行结果。Future 提供了 get() 方法让我们可以等待 Callable 结束并获取它的执行结果。</p>
<h3 id="什么是-FutureTask？"><a href="#什么是-FutureTask？" class="headerlink" title="什么是 FutureTask？"></a>什么是 FutureTask？</h3><p>FutureTask 是 Future 的一个基础实现，我们可以将它同 Executors 使用处理异步任务。通常我们不需要使用 FutureTask 类，单当我们打算重写 Future 接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读 Java FutureTask 例子，学习如何使用它。</p>
<h2 id="4-start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？"><a href="#4-start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？" class="headerlink" title="4 start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？"></a>4 start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？</h2><ul>
<li>run() 方法是线程的执行体。</li>
<li>start() 方法负责启动线程，然后 JVM 会让这个线程去执行 run() 方法。<h3 id="可以直接调用-Thread-类的-run-方法么？"><a href="#可以直接调用-Thread-类的-run-方法么？" class="headerlink" title="可以直接调用 Thread 类的 run() 方法么？"></a>可以直接调用 Thread 类的 run() 方法么？</h3></li>
<li>可以。但是如果直接调用 Thread 的 run() 方法，它的行为就会和普通的方法一样。</li>
<li>为了在新的线程中执行我们的代码，必须使用 start() 方法。</li>
</ul>
<h2 id="5-sleep-、yield-、join-方法有什么区别？为什么-sleep-和-yield-方法是静态（static）的？"><a href="#5-sleep-、yield-、join-方法有什么区别？为什么-sleep-和-yield-方法是静态（static）的？" class="headerlink" title="5 sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？"></a>5 sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？</h2><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><ul>
<li>yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。</li>
<li>yield() 方法可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程从 Running 状态转入 Runnable 状态。</li>
<li>当某个线程调用了 yield() 方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3></li>
<li>sleep() 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入 Blocked 状态。</li>
<li>该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。</li>
<li>但是，sleep() 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3></li>
<li>join() 方法会使当前线程转入 Blocked 状态，等待调用 join() 方法的线程结束后才能继续执行。</li>
<li>也就是说 join() 方法会使当前线程等待调用 join() 方法的线程结束后才能继续执行。<h3 id="为什么-sleep-和-yield-方法是静态（static）的？"><a href="#为什么-sleep-和-yield-方法是静态（static）的？" class="headerlink" title="为什么 sleep() 和 yield() 方法是静态（static）的？"></a>为什么 sleep() 和 yield() 方法是静态（static）的？</h3></li>
<li>Thread 类的 sleep() 和 yield() 方法将处理 Running 状态的线程。所以在其他处于非 Running 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。(在 run() 方法中直接使用)</li>
</ul>
<h2 id="6-wait-方法。"><a href="#6-wait-方法。" class="headerlink" title="6 wait()方法。"></a>6 wait()方法。</h2><ul>
<li>wait() ， notify() 及 notifyAll() 只能在 synchronized 语句中使用，因为 wait() 会释放锁；<h3 id="notify-和-notifyAll-。"><a href="#notify-和-notifyAll-。" class="headerlink" title="notify() 和 notifyAll()。"></a>notify() 和 notifyAll()。</h3></li>
<li>notify() 默认的唤醒策略是：先进入 wait() 的线程先被唤醒。</li>
<li>notifyAll() 唤醒所有的等待线程，默认的唤醒策略是： LIFO （后进先出）。</li>
<li>notify() 可能导致死锁，notifyAll() 开销大。</li>
</ul>
<h2 id="7-说说-sleep-方法和-wait-方法区别和共同点"><a href="#7-说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="7 说说 sleep() 方法和 wait() 方法区别和共同点?"></a>7 说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul>
<li>两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。</li>
<li>两者都可以暂停线程的执行。</li>
<li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li>
</ul>
<h2 id="8-1-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#8-1-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="8.1 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>8.1 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p>
<h2 id="8-2-start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？"><a href="#8-2-start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？" class="headerlink" title="8.2 start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？"></a>8.2 start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？</h2><ul>
<li>run() 方法是线程的执行体。</li>
<li>start() 方法负责启动线程，然后 JVM 会让这个线程去执行 run() 方法。<h3 id="可以直接调用-Thread-类的-run-方法么？-1"><a href="#可以直接调用-Thread-类的-run-方法么？-1" class="headerlink" title="可以直接调用 Thread 类的 run() 方法么？"></a>可以直接调用 Thread 类的 run() 方法么？</h3></li>
<li>可以。但是如果直接调用 Thread 的 run() 方法，它的行为就会和普通的方法一样。</li>
<li>为了在新的线程中执行我们的代码，必须使用 start() 方法。</li>
</ul>
<h2 id="9-Java-的线程优先级如何控制？高优先级的-Java-线程一定先执行吗？"><a href="#9-Java-的线程优先级如何控制？高优先级的-Java-线程一定先执行吗？" class="headerlink" title="9 Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？"></a>9 Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？</h2><p>Java并发_1.7中有相关问题</p>
<h3 id="Java-中的线程优先级如何控制"><a href="#Java-中的线程优先级如何控制" class="headerlink" title="Java 中的线程优先级如何控制"></a>Java 中的线程优先级如何控制</h3><ul>
<li>Java 中的线程优先级的范围是 [1,10]，一般来说，高优先级的线程在运行时会具有优先权。可以通过 thread.setPriority(Thread.MAX_PRIORITY) 的方式设置，默认优先级为 5。<h3 id="高优先级的-Java-线程一定先执行吗"><a href="#高优先级的-Java-线程一定先执行吗" class="headerlink" title="高优先级的 Java 线程一定先执行吗"></a>高优先级的 Java 线程一定先执行吗</h3></li>
<li>即使设置了线程的优先级，也无法保证高优先级的线程一定先执行。</li>
<li>原因：这是因为 Java 线程优先级依赖于操作系统的支持，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 Java 中线程优先级一一对应。</li>
<li>结论：Java 线程优先级控制并不可靠。</li>
</ul>
<h2 id="10-什么是守护线程？为什么要用守护线程？如何创建守护线程？"><a href="#10-什么是守护线程？为什么要用守护线程？如何创建守护线程？" class="headerlink" title="10 什么是守护线程？为什么要用守护线程？如何创建守护线程？"></a>10 什么是守护线程？为什么要用守护线程？如何创建守护线程？</h2><h3 id="什么是守护线程"><a href="#什么是守护线程" class="headerlink" title="什么是守护线程"></a>什么是守护线程</h3><ul>
<li>守护线程（Daemon Thread）是在后台执行并且不会阻止 JVM 终止的线程。</li>
<li>与守护线程（Daemon Thread）相反的，叫用户线程（User Thread），也就是非守护线程。<h3 id="为什么要用守护线程"><a href="#为什么要用守护线程" class="headerlink" title="为什么要用守护线程"></a>为什么要用守护线程</h3></li>
<li>守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。<h3 id="如何创建守护线程"><a href="#如何创建守护线程" class="headerlink" title="如何创建守护线程"></a>如何创建守护线程</h3></li>
<li>使用 thread.setDaemon(true) 可以设置 thread 线程为守护线程。</li>
<li>注意点：<ul>
<li>正在运行的用户线程无法设置为守护线程，所以 thread.setDaemon(true) 必须在 thread.start() 之前设置，否则会抛出 llegalThreadStateException 异常；</li>
<li>一个守护线程创建的子线程依然是守护线程。</li>
<li>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li>用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆。</li>
<li>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。</li>
<li>User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。</li>
</ul>
<h2 id="11-线程间是如何通信的？"><a href="#11-线程间是如何通信的？" class="headerlink" title="11 线程间是如何通信的？"></a>11 线程间是如何通信的？</h2><p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object 类中 wait(), notify() 和 notifyAll() 方法可以用于线程间通信关于资源的锁的状态。</p>
<h2 id="12-为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#12-为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="12 为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？"></a>12 为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？</h2><ul>
<li>Java 的每个对象中都有一个锁(monitor，也可以成为监视器) 并且 wait()、notify() 等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在 Java 的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是 Object 类的一部分，这样 Java 的每一个类都有用于线程间通信的基本方法</li>
<li>简单的说，这三个方法的操作对象都是锁级别的。</li>
</ul>
<hr>
<p>此博客参考资料：  </p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Snailclimb/JavaGuide</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CyC2018/CS-Notes</a></li>
<li><a href="https://github.com/dunwu/javacore" target="_blank" rel="noopener">dunwu/javacore</a></li>
<li><a href="https://github.com/crossoverJie/JCSprout" target="_blank" rel="noopener">crossoverJie/JCSprout</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 小知识 </category>
            
            <category> Java </category>
            
            <category> 并发 </category>
            
            <category> 线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP单点登录]]></title>
      <url>/2019/11/01/PHP%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="PHP单点登录"><a href="#PHP单点登录" class="headerlink" title="PHP单点登录"></a>PHP单点登录</h1><h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><figure class="image-box">
                <img src="http://111.231.250.175/img/thumb/PHP_login_makeup.jpg" alt="项目组成" title class>
                <p>项目组成</p>
            </figure>
<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>首先建立数据库连接，用于登录校验以及注册添加。</p>
<blockquote>
<p>db_config.php</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Content-type: text/html; charset=utf-8"</span>);</span><br><span class="line">$conn = <span class="keyword">new</span> mysqli(<span class="string">'eatboooo.cn'</span>,<span class="string">'root'</span>,<span class="string">'*****'</span>,<span class="string">'develop_test'</span>);</span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'数据库连接失败！'</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis"></a>连接redis</h3><p>连接redis，用于储存md5随机产生的cookieId，用于多台服务器之前的登录校验，用于保持登录状态。</p>
<blockquote>
<p>re_config.php</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Content-type: text/html; charset=utf-8"</span>);</span><br><span class="line">$redis = <span class="keyword">new</span> Redis();</span><br><span class="line">$redis-&gt;connect(<span class="string">'eatboooo.cn'</span>, <span class="number">6379</span>); <span class="comment">//连接Redis</span></span><br><span class="line">$redis-&gt;auth(<span class="string">'********'</span>); <span class="comment">//密码验证</span></span><br><span class="line">$redis-&gt;select(<span class="number">1</span>);<span class="comment">//选择数据库1</span></span><br></pre></td></tr></table></figure>

<h3 id="登录实现"><a href="#登录实现" class="headerlink" title="登录实现"></a>登录实现</h3><p>首先是简单的前端From表单。</p>
<blockquote>
<p>login.html</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"../Interface/LoginInterface.php"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userId"</span> <span class="attr">placeholder</span>=<span class="string">"手机号/邮箱"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"userPassword"</span> <span class="attr">placeholder</span>=<span class="string">"密码可见"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"slig-btn"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            没有账号？请</span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"regist.html"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"wj"</span>&gt;</span>忘记密码？<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>前端的表单提交到后端验证,同时记得对明文密码进行加密处理。</p>
<blockquote>
<p>LoginInterface.php</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">'../config/db_config.php'</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">'../config/re_config.php'</span>);</span><br><span class="line">$userId = $_POST[<span class="string">'userId'</span>];</span><br><span class="line">$userPassword = md5($_POST[<span class="string">'userPassword'</span>]); <span class="comment">//md5对明文密码进行加密</span></span><br><span class="line"><span class="keyword">if</span> ($userId == <span class="string">''</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script&gt;alert("请输入用户名！");history.go(-1);&lt;/script&gt;'</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($userPassword == <span class="string">''</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script&gt;alert("请输入密码！");history.go(-1);&lt;/script&gt;'</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">$sql</span><br><span class="line">    = <span class="string">"select * from user where userId = '$userId' and userPassword = '$userPassword'"</span>;</span><br><span class="line">$result = $conn-&gt;query($sql);</span><br><span class="line">$number = mysqli_num_rows($result);</span><br><span class="line">$msg = $result-&gt;fetch_assoc(); <span class="comment">//拿出用户信息</span></span><br><span class="line">$cid = md5(</span><br><span class="line">    uniqid(microtime(<span class="keyword">true</span>), <span class="keyword">true</span>)</span><br><span class="line">); <span class="comment">//随机生成cookieID 存储在redis和cookie中 用于保持登录状态</span></span><br><span class="line"><span class="keyword">if</span> ($number) &#123;</span><br><span class="line">    setcookie(<span class="string">'user'</span>, $cid, time() + <span class="number">3000</span>);</span><br><span class="line"><span class="comment">//    array_push($msg, $cid); 数组追加cid操作</span></span><br><span class="line">    $redis-&gt;setex($cid, <span class="number">3600</span>, json_encode($msg));</span><br><span class="line"><span class="comment">//    $redis-&gt;setex($cid, 3600, urldecode($msg));  //因为数组中有中文 所以使用urldecode方法把数组转json</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script&gt;window.location="../web/index.html";&lt;/script&gt;'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script&gt;alert("用户名或密码错误！");history.go(-1);&lt;/script&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册实现"><a href="#注册实现" class="headerlink" title="注册实现"></a>注册实现</h3><p>编写前端简单的注册表单。</p>
<blockquote>
<p>regist.html</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"../Interface/RegistInterface.php"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"psw"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"psw-p1"</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userId"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"dui"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"psw"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"psw-p1"</span>&gt;</span>输入密码<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"userPassword"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"cuo"</span>&gt;</span>密码由6-16的字母、数字、符号组成<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"psw psw2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"psw-p1"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">placeholder</span>=<span class="string">"请输入姓名"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"psw psw2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"psw-p1"</span>&gt;</span>简介<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userDescript"</span> <span class="attr">placeholder</span>=<span class="string">"请输入简介"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span> <span class="attr">class</span>=<span class="string">"psw-btn"</span>&gt;</span>立即注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sign-in"</span>&gt;</span></span><br><span class="line">        已有账号？请</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"login.html"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>后端操作mysql实现注册,注意插入的数据类型是否与数据库中的表中的数据类型一致。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">'../config/db_config.php'</span>);</span><br><span class="line">$userName = $_POST[<span class="string">'userName'</span>];</span><br><span class="line">$userPassword = md5($_POST[<span class="string">'userPassword'</span>]); <span class="comment">//md5对明文密码进行加密</span></span><br><span class="line">$userDescript = $_POST[<span class="string">'userDescript'</span>];</span><br><span class="line">$userId = $_POST[<span class="string">'userId'</span>];</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select userId from user where userId = '$_POST[userId]'"</span>;</span><br><span class="line">$result = $conn-&gt;query($sql);</span><br><span class="line">$number = mysqli_num_rows($result);</span><br><span class="line"><span class="keyword">if</span> ($number) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script&gt;alert("用户名已经存在");history.go(-1);&lt;/script&gt;'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $sql_insert = <span class="string">"INSERT INTO user() VALUES('$userId','$userName','$userPassword','$userDescript')"</span>;</span><br><span class="line">    $res_insert = $conn-&gt;query($sql_insert);</span><br><span class="line">    <span class="keyword">if</span> ($res_insert) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;script&gt;window.location="../web/login.html";&lt;/script&gt;'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;script&gt;alert('系统繁忙，请稍候！');&lt;/script&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="校验实现"><a href="#校验实现" class="headerlink" title="校验实现"></a>校验实现</h3><p>拿到cookie中的cookieID，查看服务器上redis中是否存在。</p>
<blockquote>
<p>check.php</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">'../config/re_config.php'</span>);</span><br><span class="line"><span class="keyword">if</span> ($redis-&gt;get($_COOKIE[<span class="string">"user"</span>])) &#123;</span><br><span class="line">    $msg = json_decode($redis-&gt;get($_COOKIE[<span class="string">"user"</span>]));</span><br><span class="line">    var_dump($msg);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"您害妹登录"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 小练习 </category>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 登录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL]]></title>
      <url>/2019/10/28/MySQL/</url>
      <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>MySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL<br>是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了<br>MySQL，因此它的稳定性是有保障的。MySQL是开放源代码的，因此任何人都可以在<br>GPL(General Public License)<br>的许可下下载并根据个性化的需要对其进行修改。MySQL的默认端口号是3306。</p>
<h2 id="常用命令-语句后面有分号"><a href="#常用命令-语句后面有分号" class="headerlink" title="常用命令(语句后面有分号)"></a>常用命令(语句后面有分号)</h2><p>启动MySQL服务</p>
<blockquote>
<p>net start mysql</p>
</blockquote>
<p>连接数据库</p>
<blockquote>
<p>mysql -h localhost -u root -p</p>
</blockquote>
<p>查看存储引擎</p>
<blockquote>
<p>show engines;</p>
</blockquote>
<figure class="image-box">
                <img src="https://eatboooo.gitee.io/img/thumb/show_engines.jpg" alt="查看存储引擎" title class>
                <p>查看存储引擎</p>
            </figure>

<p>其他命令 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">show databases;                  --显示所有数据库</span><br><span class="line">create database hellotest;       --创建数据库hellotest</span><br><span class="line">use hellotest;                   --使用hellotest数据库</span><br><span class="line">create table student(            --创建student</span><br><span class="line">       id int primary key auto_increment,    </span><br><span class="line">       name varchar(20),</span><br><span class="line">       pwd varchar(20),</span><br><span class="line">       enterdate date,</span><br><span class="line">       score double(4,1)</span><br><span class="line">);</span><br><span class="line">show tables;                     --显示所有的表格</span><br><span class="line">desc student;                    --显示表格结构</span><br><span class="line">insert into student values(default,&apos;zhangsan&apos;,&apos;123&apos;,&apos;2019-10-17 10:23:48&apos;,20);</span><br><span class="line">select * from student;</span><br><span class="line">drop table student;              --删除表格</span><br><span class="line">drop database hellotest;         --删除数据库</span><br><span class="line">--exit; 或者 quit;                --退出程序</span><br><span class="line">--net stop mysql;                --关闭mysql服务</span><br></pre></td></tr></table></figure>

<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>从show engines；命令我们可以查看出 MySQL<br>当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB<br>是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>
<h3 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h3><ul>
<li><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL<br>5.5版本后默认的存储引擎为InnoDB。</p>
</li>
<li><p>大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。</p>
</li>
<li><p>两者对比</p>
<ul>
<li><p>是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
</li>
<li><p>是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p>
</li>
<li><p>是否支持外键： MyISAM不支持，而InnoDB支持。</p>
</li>
<li><p>是否支持MVCC ：仅 InnoDB 支持。应对高并发事务,<br>MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ<br>两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和<br>悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。 推荐阅读： <a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">MySQL-InnoDB-MVCC多版本并发控制</a></p>
<h4 id="阿里数据库内核’2017-12’月报中对MVCC的解释是"><a href="#阿里数据库内核’2017-12’月报中对MVCC的解释是" class="headerlink" title="阿里数据库内核’2017/12’月报中对MVCC的解释是:"></a>阿里数据库内核’2017/12’月报中对MVCC的解释是:</h4><blockquote>
<p>多版本控制:<br>指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>《MySQL高性能》上面有一句话这样写到:</p>
<blockquote>
<p>不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>
</blockquote>
<p>一般情况下我们选择 InnoDB<br>都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>
<h2 id="字符集及校对规则"><a href="#字符集及校对规则" class="headerlink" title="字符集及校对规则"></a>字符集及校对规则</h2><p><strong>字符集指的是一种从二进制编码到某类字符符号的映射</strong>。校对规则则是指某种字符集下的排序规则。MySQL中每一种字符集都会对应一系列的校对规则。</p>
<p>MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《Java工程师修炼之道》</p>
<p>详细内容可以参考： <a href="https://www.cnblogs.com/geaozhang/p/6724393.html#MySQLyuzifuji" target="_blank" rel="noopener">MySQL字符集及校对规则的理解</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<ul>
<li><p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
</li>
<li><p>MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
</li>
<li><p>InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 PS：整理自《Java工程师修炼之道》</p>
</li>
<li><p>更多请看<a href>MySQL索引</a>。</p>
<h2 id="查询缓存的使用"><a href="#查询缓存的使用" class="headerlink" title="查询缓存的使用"></a>查询缓存的使用</h2><blockquote>
<p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p>
</blockquote>
</li>
</ul>
<p>my.cnf加入以下配置，重启MySQL开启查询缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type=1</span><br><span class="line">query_cache_size=600000</span><br></pre></td></tr></table></figure>

<p>MySQL执行以下命令也可以开启查询缓存 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global  query_cache_type=1;</span><br><span class="line">set global  query_cache_size=600000;</span><br></pre></td></tr></table></figure>

<p>如上，开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。</p>
<p>缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p>
<p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。<br>因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：</p>
<p><code>select sql_no_cache count(*) from usr;</code> </p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h3 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h3><ol>
<li>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性（Consistency）：<br>执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li>隔离性（Isolation）：<br>并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性（Durability）：<br>一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<h3 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h3>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</li>
</ol>
<ul>
<li>脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li>丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li>不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li>幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<h4 id="不可重复读和幻读区别："><a href="#不可重复读和幻读区别：" class="headerlink" title="不可重复读和幻读区别："></a>不可重复读和幻读区别：</h4><p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<h3 id="事务隔离级别有哪些-MySQL的默认隔离级别是"><a href="#事务隔离级别有哪些-MySQL的默认隔离级别是" class="headerlink" title="事务隔离级别有哪些?MySQL的默认隔离级别是?"></a>事务隔离级别有哪些?MySQL的默认隔离级别是?</h3><h4 id="SQL-标准定义了四个隔离级别："><a href="#SQL-标准定义了四个隔离级别：" class="headerlink" title="SQL 标准定义了四个隔离级别："></a>SQL 标准定义了四个隔离级别：</h4><ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>✔</td>
<td>✔</td>
<td>✘</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>✔</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>✘</td>
<td>✘</td>
<td>✘</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看</p>
<p><code>SELECT @@tx_isolation;</code> </p>
<p><img src="https://eatboooo.gitee.io/img/thumb/select_@@tx_isolation.jpg" alt="SELECT @@tx_isolation;"></p>
<p>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。</p>
<h2 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h2><h3 id="MyISAM和InnoDB存储引擎使用的锁："><a href="#MyISAM和InnoDB存储引擎使用的锁：" class="headerlink" title="MyISAM和InnoDB存储引擎使用的锁："></a>MyISAM和InnoDB存储引擎使用的锁：</h3><ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
</ul>
<h3 id="表级锁和行级锁对比："><a href="#表级锁和行级锁对比：" class="headerlink" title="表级锁和行级锁对比："></a>表级锁和行级锁对比：</h3><ul>
<li><p>表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p>
</li>
<li><p>行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p>
</li>
<li><p>详细内容可以参考：<br><a href="https://blog.csdn.net/qq_34337272/article/details/80611486" target="_blank" rel="noopener">MySQL锁机制</a>。</p>
<h3 id="InnoDB存储引擎的锁的算法有三种："><a href="#InnoDB存储引擎的锁的算法有三种：" class="headerlink" title="InnoDB存储引擎的锁的算法有三种："></a>InnoDB存储引擎的锁的算法有三种：</h3></li>
<li><p>Record lock：单个行记录上的锁</p>
</li>
<li><p>Gap lock：间隙锁，锁定一个范围，不包括记录本身</p>
</li>
<li><p>Next-key lock：record+gap 锁定一个范围，包含记录本身</p>
</li>
</ul>
<h3 id="相关知识点："><a href="#相关知识点：" class="headerlink" title="相关知识点："></a>相关知识点：</h3><ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><h3 id="当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下："><a href="#当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：" class="headerlink" title="当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下："></a>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</h3><ol>
<li><p>限定数据的范围<br>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
</li>
<li><p>读/写分离<br>经典的数据库拆分方案，主库负责写，从库负责读；</p>
</li>
<li><p>垂直分区<br><strong>根据数据库里面数据表的相关性进行拆分。<br>例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</strong></p>
<p>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。<br>如下图所示，这样来说大家应该就更容易理解了。<br><img src="https://eatboooo.gitee.io/img/thumb/vertical_partition.jpg" alt="垂直拆分"></p>
<ul>
<li>垂直拆分的优点：可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
</li>
<li><p>水平分区<br><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。<br>水平拆分可以支撑非常大的数据量。</strong><br>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。<br><img src="https://eatboooo.gitee.io/img/thumb/horizontal_partition.jpg" alt="水平拆分"></p>
<p> 水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>
<p> 水平拆分能够支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决<br> ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐<br> 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度<br> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<h4 id="下面补充一下数据库分片的两种常见方案："><a href="#下面补充一下数据库分片的两种常见方案：" class="headerlink" title="下面补充一下数据库分片的两种常见方案："></a>下面补充一下数据库分片的两种常见方案：</h4><ul>
<li>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。<br>当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li>
<li>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
</li>
</ol>
<p>详细内容可以参考： <a href="https://segmentfault.com/a/1190000006158186" target="_blank" rel="noopener">MySQL大表优化方案</a>。</p>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd" target="_blank" rel="noopener">一条SQL语句在MySQL中如何执行的</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd" target="_blank" rel="noopener">MySQL高性能优化规范建议</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd" target="_blank" rel="noopener">腾讯面试：一条SQL语句执行得很慢的原因有哪些？—不看后悔系列</a></p>
<hr>
<p>此博客参考资料：  </p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Snailclimb/JavaGuide</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CyC2018/CS-Notes</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 小知识 </category>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java并发]]></title>
      <url>/2019/10/28/Java%E5%B9%B6%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="1-并发简介"><a href="#1-并发简介" class="headerlink" title="1.并发简介"></a>1.并发简介</h2><h3 id="1-1-什么是进程？什么是线程？进程和线程的区别是什么？"><a href="#1-1-什么是进程？什么是线程？进程和线程的区别是什么？" class="headerlink" title="1.1.什么是进程？什么是线程？进程和线程的区别是什么？"></a>1.1.什么是进程？什么是线程？进程和线程的区别是什么？</h3><ul>
<li><p>什么是进程？</p>
<ul>
<li>可以看做一个正在运行的程序。</li>
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。</li>
<li>进程是操作系统进行资源分配的基本单位。</li>
</ul>
</li>
<li><p>什么是线程？</p>
<ul>
<li>线程是操作系统能够进行运算调度的最小单位</li>
</ul>
</li>
<li><p>进程和线程的区别是什么？</p>
<ul>
<li><p>一个程序至少有一个进程，一个进程至少有一个线程。</p>
</li>
<li><p>线程比进程划分更细，所以执行开销更小，并发性更高。</p>
</li>
<li><p>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</p>
</li>
<li><figure class="image-box">
                <img src="https://eatboooo.gitee.io/img/thumb/jvm_thread.png" alt="JVM_thread 概览" title class>
                <p>JVM_thread 概览</p>
            </figure>





</li>
</ul>
</li>
</ul>
<h3 id="1-2-并发（多线程）编程的好处是什么？"><a href="#1-2-并发（多线程）编程的好处是什么？" class="headerlink" title="1.2. 并发（多线程）编程的好处是什么？"></a>1.2. 并发（多线程）编程的好处是什么？</h3><ul>
<li>更有效率的利用多处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h3 id="1-3-并发一定比串行更快吗？"><a href="#1-3-并发一定比串行更快吗？" class="headerlink" title="1.3. 并发一定比串行更快吗？"></a>1.3. 并发一定比串行更快吗？</h3><p>答：否。</p>
<p>要点：<strong>创建线程和线程上下文切换有一定开销</strong>。</p>
<p>说明：即使是单核处理器也支持多线程。CPU 通过给每个线程分配时间切片的算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保持上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>引申</p>
<ul>
<li>如何减少上下文切换？<ul>
<li>尽量少用锁</li>
<li>CAS 算法</li>
<li>线程数要合理</li>
<li>协程：在单线程中实现多任务调度，并在单线程中维持多个任务的切换</li>
</ul>
</li>
</ul>
<h3 id="1-4-并发与并行的区别是什么？？"><a href="#1-4-并发与并行的区别是什么？？" class="headerlink" title="1.4.并发与并行的区别是什么？？"></a>1.4.并发与并行的区别是什么？？</h3><ul>
<li>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</li>
<li>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li>
<li><figure class="image-box">
                <img src="https://eatboooo.gitee.io/img/thumb/Concurrent.jpg" alt="并发-Concurrency" title class>
                <p>并发-Concurrency</p>
            </figure></li>
<li><figure class="image-box">
                <img src="https://eatboooo.gitee.io/img/thumb/Parallel.jpg" alt="并行-Parallel" title class>
                <p>并行-Parallel</p>
            </figure>

</li>
</ul>
<h3 id="1-5-如何让正在运行的线程暂停一段时间？"><a href="#1-5-如何让正在运行的线程暂停一段时间？" class="headerlink" title="1.5.如何让正在运行的线程暂停一段时间？"></a>1.5.如何让正在运行的线程暂停一段时间？</h3><ul>
<li>我们可以使用 Thread 类的 sleep() 方法让线程暂停一段时间。</li>
<li>需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，并且根据线程调度，它将得到执行。</li>
</ul>
<h3 id="1-6-java中sleep-和wait-区别是什么？"><a href="#1-6-java中sleep-和wait-区别是什么？" class="headerlink" title="1.6.java中sleep()和wait()区别是什么？"></a>1.6.java中sleep()和wait()区别是什么？</h3><ul>
<li>sleep()方法是Thread类的静态方法,wait()是Object超类(superClass,就是父类)的成员方法。</li>
<li>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。</li>
<li>当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。</li>
<li>sleep()方法需要抛异常,wait()方法不需要。</li>
<li>sleep()方法可以在任何地方使用,wait()方法只能在同步方法和同步代码块中使用。</li>
<li>更多请看 <a href>Java中的锁</a>。</li>
</ul>
<h3 id="1-7-什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing"><a href="#1-7-什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing" class="headerlink" title="1.7.什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)?"></a>1.7.什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)?</h3><p>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。</p>
<p>时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。</p>
<p>分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java<br>虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。(Java线程_9中有说明)</p>
<h3 id="1-8-在多线程中，什么是上下文切换-context-switching-？"><a href="#1-8-在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="1.8.在多线程中，什么是上下文切换(context-switching)？"></a>1.8.在多线程中，什么是上下文切换(context-switching)？</h3><p>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。<br>这就像我们同时读两本书，当我们在读一本英文的技术书籍时，发现某个单词不认识， 于是便打开中英文词典，但是在放下英文书籍之前，大脑必须先记住这本书读到了多少页的第多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读 书效率的，同样上下文切换也会影响多线程的执行速度。</p>
<h3 id="1-9-什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#1-9-什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="1.9.什么是死锁(Deadlock)？如何分析和避免死锁？"></a>1.9.什么是死锁(Deadlock)？如何分析和避免死锁？</h3><p>死锁是指两个以上的线程永远相互阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。</p>
<p>分析死锁，我们需要查看 Java 应用程序的线程转储。我们需要找出那些状态为 BLOCKED 的线程和他们等待的资源。每个资源都有一个唯一的 id，用这个 id 我们可以找出哪些线程已经拥有了它的对象锁。</p>
<p>避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。</p>
<hr>
<p>此博客参考资料：  </p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Snailclimb/JavaGuide</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CyC2018/CS-Notes</a></li>
<li><a href="https://github.com/dunwu/javacore" target="_blank" rel="noopener">dunwu/javacore</a></li>
<li><a href="https://github.com/crossoverJie/JCSprout" target="_blank" rel="noopener">crossoverJie/JCSprout</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 小知识 </category>
            
            <category> Java </category>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java并发]]></title>
      <url>/2019/10/14/JavaConcurrent/</url>
      <content type="html"><![CDATA[<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="1-并发简介"><a href="#1-并发简介" class="headerlink" title="1.并发简介"></a>1.并发简介</h2><h3 id="1-1-什么是进程？什么是线程？进程和线程的区别是什么？"><a href="#1-1-什么是进程？什么是线程？进程和线程的区别是什么？" class="headerlink" title="1.1.什么是进程？什么是线程？进程和线程的区别是什么？"></a>1.1.什么是进程？什么是线程？进程和线程的区别是什么？</h3><ul>
<li>什么是进程？<ul>
<li>可以看做一个正在运行的程序。</li>
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。</li>
<li>进程是操作系统进行资源分配的基本单位。</li>
</ul>
</li>
<li>什么是线程？</li>
</ul>
<ul>
<li>线程是操作系统能够进行运算调度的最小单位</li>
</ul>
<ul>
<li><p>进程和线程的区别是什么？  </p>
<ul>
<li><p>一个程序至少有一个进程，一个进程至少有一个线程。</p>
</li>
<li><p>线程比进程划分更细，所以执行开销更小，并发性更高。</p>
</li>
<li><p>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</p>
</li>
<li><figure class="image-box">
                <img src="https://eatboooo.gitee.io/eblog/img/thumb/jvm_thread.png" alt="JVM_thread 概览" title class>
                <p>JVM_thread 概览</p>
            </figure>





</li>
</ul>
</li>
</ul>
<h3 id="1-2-并发（多线程）编程的好处是什么？"><a href="#1-2-并发（多线程）编程的好处是什么？" class="headerlink" title="1.2. 并发（多线程）编程的好处是什么？"></a>1.2. 并发（多线程）编程的好处是什么？</h3><ul>
<li>更有效率的利用多处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h3 id="1-3-并发一定比串行更快吗？"><a href="#1-3-并发一定比串行更快吗？" class="headerlink" title="1.3. 并发一定比串行更快吗？"></a>1.3. 并发一定比串行更快吗？</h3><p>答：否。</p>
<p>要点：<strong>创建线程和线程上下文切换有一定开销</strong>。</p>
<p>说明：即使是单核处理器也支持多线程。CPU 通过给每个线程分配时间切片的算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保持上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>引申</p>
<ul>
<li>如何减少上下文切换？<ul>
<li>尽量少用锁</li>
<li>CAS 算法</li>
<li>线程数要合理</li>
<li>协程：在单线程中实现多任务调度，并在单线程中维持多个任务的切换</li>
</ul>
</li>
</ul>
<h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
        <categories>
            
            <category> 小知识 </category>
            
            <category> Java </category>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
