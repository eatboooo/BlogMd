---
title: Java并发  
date: 2019/10/11
categories:
- 小知识
- Java
- 并发
tags:
- Java
- 并发
src: //eatboooo.gitee.io/img/background/jvm_thread_h.png
---

# Java并发

## 1.并发简介

### 1.1.什么是进程？什么是线程？进程和线程的区别是什么？

+ 什么是进程？
  - 可以看做一个正在运行的程序。
  - 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。
  - 进程是操作系统进行资源分配的基本单位。
+ 什么是线程？

  - 线程是操作系统能够进行运算调度的最小单位

+ 进程和线程的区别是什么？

  -  一个程序至少有一个进程，一个进程至少有一个线程。

  - 线程比进程划分更细，所以执行开销更小，并发性更高。

  - 进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。

  - ![JVM_thread 概览](https://eatboooo.gitee.io/img/thumb/jvm_thread.png)





### 1.2. 并发（多线程）编程的好处是什么？



+ 更有效率的利用多处理器核心
+ 更快的响应时间
+ 更好的编程模型

### 1.3. 并发一定比串行更快吗？

答：否。

要点：**创建线程和线程上下文切换有一定开销**。

说明：即使是单核处理器也支持多线程。CPU 通过给每个线程分配时间切片的算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保持上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以**任务从保存到再加载的过程就是一次上下文切换**。

引申

+ 如何减少上下文切换？
  - 尽量少用锁
  - CAS 算法
  - 线程数要合理
  - 协程：在单线程中实现多任务调度，并在单线程中维持多个任务的切换

### 1.4.并发与并行的区别是什么？？
- 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。
- 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
- ![并发-Concurrency](https://eatboooo.gitee.io/img/thumb/Concurrent.jpg)
- ![并行-Parallel](https://eatboooo.gitee.io/img/thumb/Parallel.jpg)

### 1.5.如何让正在运行的线程暂停一段时间？
- 我们可以使用 Thread 类的 sleep() 方法让线程暂停一段时间。
- 需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，并且根据线程调度，它将得到执行。

### 1.6.java中sleep()和wait()区别是什么？
+ sleep()方法是Thread类的静态方法,wait()是Object超类(superClass,就是父类)的成员方法。
+ sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。
+ 当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。
+ sleep()方法需要抛异常,wait()方法不需要。
+ sleep()方法可以在任何地方使用,wait()方法只能在同步方法和同步代码块中使用。
+ 更多请看 [Java中的锁]()。

### 1.7.什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)?
线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。

时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。

分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java
虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。(Java线程_9中有说明)

### 1.8.在多线程中，什么是上下文切换(context-switching)？
上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。  
这就像我们同时读两本书，当我们在读一本英文的技术书籍时，发现某个单词不认识， 于是便打开中英文词典，但是在放下英文书籍之前，大脑必须先记住这本书读到了多少页的第多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读 书效率的，同样上下文切换也会影响多线程的执行速度。

### 1.9.什么是死锁(Deadlock)？如何分析和避免死锁？
死锁是指两个以上的线程永远相互阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。

分析死锁，我们需要查看 Java 应用程序的线程转储。我们需要找出那些状态为 BLOCKED 的线程和他们等待的资源。每个资源都有一个唯一的 id，用这个 id 我们可以找出哪些线程已经拥有了它的对象锁。

避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。

---
此博客参考资料：  
+ [Snailclimb/JavaGuide](https://github.com/Snailclimb/JavaGuide)
+ [CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)
+ [dunwu/javacore](https://github.com/dunwu/javacore)
+ [crossoverJie/JCSprout](https://github.com/crossoverJie/JCSprout)
